plot
}
mean_plot <- plot_rdm(mean_rdm)
og_plot <- plot_rdm(og_cor)
subject_plot <- plot_rdm(subject_cors[[1]])
mean_plot
og_plot
subject_plot
#import category vectors
category_vectors <- read.table("./data/CategoryVectors")
category_labels <- read.table("./data/CategoryLabels")
#make RDM for category
category_rdm <- function(cat_vector) {
rdm <- matrix(nrow = length(cat_vector), ncol = length(cat_vector))
for (i in 1:length(cat_vector)) {
for(j in 1:length(cat_vector)) {
rdm[i,j] <- as.numeric(cat_vector[i] == cat_vector[j])
}
}
rdm
}
category_rdm_for_index <- function(index) {
category_rdm(category_vectors[,index])
}
#compare same vs different in one category
compare_category <- function(cat_index, correlations, filter = 0) {
cat_rdm <- category_rdm_for_index(cat_index)
same_cat <- c()
diff_cat <- c()
for (i in 1:nrow(cat_rdm)) {
for (j in 1:ncol(cat_rdm)) {
if (i < j) { #remove i == j and make sure that i,j and j,i are not both included
#check if i,j should be included based on filter
if (filter > 0) {
if (category_vectors[i,filter] == 0 | category_vectors[j,filter] == 0) {
include <- FALSE
}
else { include <- TRUE}
}
else { include <- TRUE }
#add correlation[i,j] to vector
if (include) {
if (cat_rdm[i,j] == 1) {
same_cat <- c(same_cat, c(correlations[i,j]))
}
else {
diff_cat <- c(diff_cat, c(correlations[i,j]))
}
}
}
}
}
#print descriptives
print('Same category:')
print(c(mean(same_cat), sd(same_cat)))
print('Different category:')
print(c(mean(diff_cat), sd(diff_cat)))
#perform t-test
t.test(same_cat, diff_cat, alternative = "two.sided", paired = FALSE)
}
perform_anova <- function(cat1, cat2, correlations) {
cat1_rdm <- category_rdm_for_index(cat1)
cat2_rdm <- category_rdm_for_index(cat2)
results <- data.frame()
for (i in 1:nrow(correlations)) {
for (j in 1:ncol(correlations)) {
if (i < j) { #remove i == j and make sure that i,j and j,i are not both included
#add correlation to dataframe
results <- rbind(results, c(cat1_rdm[i,j], cat2_rdm[i,j], correlations[i,j])                         )
}
}
}
colnames(results) <- c("same_cat1", "same_cat2", "correlation")
anova <- aov(correlation ~ same_cat1 + same_cat2 + same_cat1:same_cat2, data = results)
summary(anova)
}
macaque <- read.table('./data/NeuroRDM')
macaque_rdm <- unname(macaque)
macaque_rdm <- as.matrix(macaque_rdm)
plot_macaque <- function() {
melted_data <- melt(macaque_rdm)
plot <- ggplot(data = melted_data, aes(Var2, Var1, fill = value)) +
geom_tile() +
scale_fill_gradient(low = "darkslategray", high = "darkseagreen1", name = "Dissimilarity", limit = c(0, 10)) +
xlab("image") +
ylab("image") +
theme_minimal()
plot
}
plot_rdm(macaque_rdm)
#compare two RDMS
compare_rdms <- function(rdm1, rdm2, filter = 0) {
#give the pairwise values
rdm1_values <- c()
rdm2_values <- c()
for (i in 1:nrow(rdm1)) {
for (j in 1:ncol(rdm1)) {
if (i < j) {
#check if i,j should be included based on filter
if (filter > 0) {
if (category_vectors[i,filter] == 0 | category_vectors[j,filter] == 0) {
include <- FALSE
}
else { include <- TRUE}
}
else { include <- TRUE }
#add to vectors
if (include) {
rdm1_values <- c(rdm1_values, c(rdm1[i,j]))
rdm2_values <- c(rdm2_values, c(rdm2[i,j]))
}
}
}
}
list(rdm1_values, rdm2_values)
}
correlate_rdms <- function(rdm1, rdm2, filter = 0) {
values <- compare_rdms(rdm1, rdm2, filter)
cor.test(values[[1]], values[[2]])
}
plot_human_macaque_scatter <- function() {
values <- compare_rdms(mean_rdm, macaque_rdm)
human_macaque_df <- data.frame(Human = values[[1]], Macaque = values[[2]])
ggplot(data = human_macaque_df) +
geom_point(aes(x = Human, y = Macaque), color = "darkseagreen4", size=0.5) +
theme_classic()
}
correlate_rdms(mean_rdm, macaque_rdm)
correlate_rdms(mean_rdm, macaque_rdm, filter = 1)
correlate_rdms(mean_rdm, macaque_rdm, filter = 2)
behaviour <- read.table('./data/BehaviourRDM')
behaviour_rdm <- unname(behaviour)
behaviour_rdm <- as.matrix(behaviour_rdm)
plot_rdm(behaviour_rdm)
hmax <- read.table('./data/HmaxRDM')
hmax_rdm <- unname(hmax)
hmax_rdm <- as.matrix(hmax_rdm)
plot_rdm(hmax_rdm)
library(ggplot2)
# we will work with points 1 to 250 (cm)
scale.points <- c(1:250)
# we create a dataframe for plotting
example.height <- data.frame(x=scale.points)
# we use sapply, which is a vectorized function application; see help if you don't understand it
# we add y, which is just the probability density function described above (normal distribution)
example.height$y <- sapply(example.height$x, function(x) {dnorm(x, mean=180, sd=10)})
# this starts the plot creation
g1 <- ggplot(example.height, aes(x=x, y=y))
# we make the plot more pretty: we specify it should fill in area and add labels
g1 <- g1 + geom_area(fill="green", alpha=.4)  + xlab("height") + ylab("P") + theme_gray(20)
g1
literal.listener <- function(x, threshold, densityf, cumulativef) {
ifelse(
x>=threshold,
densityf(x)/(1-cumulativef(threshold)),
0
)
}
threshold <- 170
example.height$updated <- sapply(example.height$x, function(x) {literal.listener(x=x, threshold=threshold, densityf=function(x) {dnorm(x, 180, 10)}, cumulativef=function(x) {pnorm(x, 180, 10)} )})
# this starts the plot creation
g1 <- ggplot(example.height, aes(x=x, y=y))
g1 <- g1 + geom_area(fill="green", alpha=.4)
# we add the result of updated belief
g1 <- g1 + geom_area(aes(y=updated),fill="steelblue", alpha=.4)
g1 <- g1 + xlab("height") + ylab("P") + theme_gray(20)
g1
expected.success <- function(threshold, scale.points, densityf, cumulativef) {
sum(sapply(scale.points[1]:max(1, scale.points[which(scale.points==threshold)-1]), function(x) {densityf(x) * densityf(x)})) +
sum(sapply(scale.points[which(scale.points==threshold)]:scale.points[length(scale.points)], function(x) {densityf(x) * literal.listener(x, threshold, densityf, cumulativef)}))
}
#Task 1
utility <- function(threshold, scale.points, coverage.parameter, densityf, cumulativef) {
ES <- expected.success(threshold, scale.points, densityf, cumulativef)
cumulative <- coverage.parameter * cumulativef((threshold))
ES + cumulative
}
probability.threshold <- function(threshold, scale.points, lambda, coverage.parameter, densityf, cumulativef) {
threshold_value <- function(t) { exp(lambda * utility(t, scale.points, coverage.parameter, densityf, cumulativef)) }
numerator <- threshold_value(threshold)
denominator <- sum(sapply(scale.points, threshold_value ))
numerator / denominator
}
#probabilities for different threshold values
lambda <- 50
coverage <- 0
densityf <- function(x) {dnorm(x, mean=180, sd=10)}
cumulativef <- function(x) {pnorm(x, 180, 10)}
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
use.adjective <- function(degree, scale.points, lambda, coverage.parameter, densityf, cumulativef) {
#scale.points.leq <- scale.points[scale.points <= degree]
probability.of.thresholds <- probability.of.thresholds[scale.points <= degree]
sigma <- sum(probability.of.thresholds)
sigma
}
#probability.threshold is a probability, so if you sum up all values it generates, the result should be 1
round(sum(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 1
#for narrow normal distribution, prob. threshold should be max just one value above the average
which(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})==max(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 6
#use.adjective should be very unlikely on values 5 and smaller and very likely afterwards
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[5], 3) == 0.005
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[6], 3) == 1
setwd("~/Uni/COMO/labs/Assignment 3")
#probabilities for different threshold values
lambda <- 50
coverage <- 0
densityf <- function(x) {dnorm(x, mean=180, sd=10)}
cumulativef <- function(x) {pnorm(x, 180, 10)}
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
use.adjective <- function(degree, scale.points, lambda, coverage.parameter, densityf, cumulativef) {
#scale.points.leq <- scale.points[scale.points <= degree]
probability.of.thresholds <- probability.of.thresholds[scale.points <= degree]
sigma <- sum(probability.of.thresholds)
sigma
}
round(sum(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 1
which(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})==max(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 6
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[5], 3) == 0.005
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[6], 3) == 1
use.adjective <- function(degree, scale.points, lambda, coverage.parameter, densityf, cumulativef) {
scale.points.leq <- scale.points[scale.points <= degree]
#probability.of.thresholds <- probability.of.thresholds[scale.points <= degree]
sigma <- sum(probability.of.thresholds)
sigma
}
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[5], 3) == 0.005
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[6], 3) == 1
expected.success <- function(threshold, scale.points, densityf, cumulativef) {
ifelse(threshold>min(scale.points), sum(sapply(scale.points[scale.points<threshold], function(x) {densityf(x) * densityf(x)})), 0) +
sum(sapply(scale.points[scale.points>=threshold], function(x) {densityf(x) * literal.listener(x, threshold, densityf, cumulativef)}))
}
use.adjective <- function(degree, scale.points, lambda, coverage.parameter, densityf, cumulativef, use_existing_probabilities = FALSE) {
if (use_existing_probabilities)  {
probability <- probability.of.thresholds[scale.points <= degree]
}
else {
scale.points.leq <- scale.points[scale.points <= degree]
probability <- sapply(scale.points.leq,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
}
sigma <- sum(probability)
sigma
}
#probability.threshold is a probability, so if you sum up all values it generates, the result should be 1
round(sum(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 1
#for narrow normal distribution, prob. threshold should be max just one value above the average
which(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})==max(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 6
#use.adjective should be very unlikely on values 5 and smaller and very likely afterwards
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[5], 3) == 0.005
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[6], 3) == 1
#sigma for different threshold values
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, use_existing_probabilities = TRUE))
plotdata <- data.frame("height" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds)
#plot probabilites
g1 <- ggplot(plotdata) +
geom_area(aes(x=height, y=P), fill="green", alpha=.4) +
g2 <- ggplot(plotdata) +
geom_area(aes(x=height, y=sigma), fill="steelblue", alpha=.4)
#plot probabilites
g1 <- ggplot(plotdata) +
geom_area(aes(x=height, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=height, y=sigma), fill="steelblue", alpha=.4)
g1
g2
#plot probabilites
plot_probabilities <- function(plotdata) {
g <- ggplot(plotdata) +
geom_area(aes(x=height, y=P), fill="green", alpha=.4)
g
}
plot_sigma <- function(plotdata) {
g <- ggplot(plotdata) +
geom_area(aes(x=height, y=sigma), fill="steelblue", alpha=.4)
g
}
scale.points <- c(1:150)
densityf <- function(x) {dnorm(x, mean=100, sd=15)}
cumulativef <- function(x) {pnorm(x, 100, 15)}
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, use_existing_probabilities = TRUE))
plotdata <- data.frame("height" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds)
plot_probabilities(plotdata)
plot_sigma(plotdata)
plot_probabilities(plotdata)
scale.points <- c(50:150)
densityf <- function(x) {dnorm(x, mean=100, sd=15)}
cumulativef <- function(x) {pnorm(x, 100, 15)}
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, use_existing_probabilities = TRUE))
plotdata <- data.frame("height" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds)
plot_probabilities(plotdata)
plot_sigma(plotdata)
plot_probabilities(plotdata)
#plot probabilites
g1 <- ggplot(plotdata) +
geom_area(aes(x=IQ, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=IQ, y=sigma), fill="steelblue", alpha=.4)
g1
plotdata <- data.frame("IQ" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds)
#plot probabilites
g1 <- ggplot(plotdata) +
geom_area(aes(x=IQ, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=IQ, y=sigma), fill="steelblue", alpha=.4)
g1
expected.success.values <- sapply(scale.points(function(d) expected.success(d,  scale.points, densityf, cumulativef)))
plotdata <- data.frame("IQ" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
expected.success.values <- sapply(scale.points(function(d) expected.success(d,  scale.points, densityf, cumulativef)))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame("IQ" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
g3 <- ggplot(plotdata) +
geom_area(aes(x=IQ, y=Success), fill="steelblue", alpha=.4)
g3
scale.points <- c(0:150)
densityf <- function(x) {dnorm(x, mean=100, sd=15)}
cumulativef <- function(x) {pnorm(x, 100, 15)}
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, use_existing_probabilities = TRUE))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame("IQ" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
#plot probabilites
g1 <- ggplot(plotdata) +
geom_area(aes(x=IQ, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=IQ, y=sigma), fill="steelblue", alpha=.4)
g3 <- ggplot(plotdata) +
geom_area(aes(x=IQ, y=Success), fill="steelblue", alpha=.4)
g3
get_plotdata <- function (scale.points, densityf, cumulativef, name) {
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, use_existing_probabilities = TRUE))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame(name = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
}
scale.points <- c(0:150)
densityf <- function(x) {dnorm(x, mean=100, sd=15)}
cumulativef <- function(x) {pnorm(x, 100, 15)}
plotdata <- get_plotdata(scale.points, densityf, cumulativef, "IQ")
scale.points <- c(0:30)
densityf <- function(x) {dgamma(x, mean=2, sd=1)}
cumulativef <- function(x) {pgamma(x, 2, 1)}
plotdata <- get_plotdata(scale.points, densityf, cumulativef, "IQ")
scale.points <- c(0:30)
densityf <- function(x) {dgamma(2, 1)}
cumulativef <- function(x) {pgamma(2, 1)}
plotdata <- get_plotdata(scale.points, densityf, cumulativef, "Time")
plotdata
g1 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=sigma), fill="steelblue", alpha=.4)
g3 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=Success), fill="steelblue", alpha=.4)
g1
get_plotdata <- function (scale.points, densityf, cumulativef) {
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, use_existing_probabilities = TRUE))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame(var = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
}
get_plotdata <- function (scale.points, densityf, cumulativef, name) {
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, use_existing_probabilities = TRUE))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame(var = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
colnames(plotdata) = c(name, "P", "sigma", "Success")
plotdata
}
plotdata <- get_plotdata(scale.points, densityf, cumulativef, "Time")
plotdata
#plot probabilites
g1 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=sigma), fill="steelblue", alpha=.4)
g3 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=Success), fill="steelblue", alpha=.4)
g1
g2
g3
g1
scale.points <- c(0:30)
densityf <- function(x) {dgamma(x, 2, 1)}
cumulativef <- function(x) {pgamma(x, 2, 1)}
plotdata <- get_plotdata(scale.points, densityf, cumulativef, "Time")
scale.points <- c(0:30)
densityf <- function(x) {dgamma(x, shape = 2, scale = 1)}
cumulativef <- function(x) {pgamma(x, shape = 2, scale = 1)}
plotdata <- get_plotdata(scale.points, densityf, cumulativef, "Time")
g1 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=sigma), fill="steelblue", alpha=.4)
g3 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=Success), fill="steelblue", alpha=.4)
g1
use.adjective <- function(degree, scale.points, lambda, coverage.parameter, densityf, cumulativef, existing_probabilities = FALSE) {
if (existing_probabilities)  {
probability <- existing_probabilities[scale.points <= degree]
}
else {
scale.points.leq <- scale.points[scale.points <= degree]
probability <- sapply(scale.points.leq,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
}
sigma <- sum(probability)
sigma
}
#probability.threshold is a probability, so if you sum up all values it generates, the result should be 1
round(sum(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 1
#for narrow normal distribution, prob. threshold should be max just one value above the average
which(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})==max(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 6
#use.adjective should be very unlikely on values 5 and smaller and very likely afterwards
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[5], 3) == 0.005
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[6], 3) == 1
get_plotdata <- function (scale.points, densityf, cumulativef, name) {
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, existing_probabilities = probability.of.thresholds))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame(var = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
colnames(plotdata) = c(name, "P", "sigma", "Success")
plotdata
}
scale.points <- c(0:150)
densityf <- function(x) {dnorm(x, mean=100, sd=15)}
cumulativef <- function(x) {pnorm(x, 100, 15)}
plotdata <- get_plotdata(scale.points, densityf, cumulativef, "IQ")
scale.points <- c(0:30)
densityf <- function(x) {dgamma(x, shape = 2, scale = 1)}
cumulativef <- function(x) {pgamma(x, shape = 2, scale = 1)}
plotdata <- get_plotdata(scale.points, densityf, cumulativef, "Time")
use.adjective <- function(degree, scale.points, lambda, coverage.parameter, densityf, cumulativef, use_existing_probabilities = FALSE) {
if (use_existing_probabilities)  {
probability <- probability.of.thresholds[scale.points <= degree]
}
else {
scale.points.leq <- scale.points[scale.points <= degree]
probability <- sapply(scale.points.leq,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
}
sigma <- sum(probability)
sigma
}
# Help - tests you should pass
#probability.threshold is a probability, so if you sum up all values it generates, the result should be 1
round(sum(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 1
#for narrow normal distribution, prob. threshold should be max just one value above the average
which(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})==max(sapply(1:10, function(x) {probability.threshold(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})}))) == 6
#use.adjective should be very unlikely on values 5 and smaller and very likely afterwards
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[5], 3) == 0.005
round(sapply(1:10, function(x) {use.adjective(x, 1:10, 50, 0, function(x) {dnorm(x, 5, 1)}, function(x) {pnorm(x, 5, 1)})})[6], 3) == 1
scale.points <- c(0:150)
densityf <- function(x) {dnorm(x, mean=100, sd=15)}
cumulativef <- function(x) {pnorm(x, 100, 15)}
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, existing_probabilities = TRUE))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame("IQ" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
scale.points <- c(0:30)
densityf <- function(x) {dgamma(x, shape = 2, scale = 1)}
cumulativef <- function(x) {pgamma(x, shape = 2, scale = 1)}
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, existing_probabilities = TRUE))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame("Time" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
#plot probabilites
g1 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=sigma), fill="steelblue", alpha=.4)
g3 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=Success), fill="steelblue", alpha=.4)
probability.of.thresholds <- sapply(scale.points,
function(d) probability.threshold(d, scale.points, lambda, coverage, densityf, cumulativef))
sigma.of.thresholds <- sapply(scale.points,
function(d) use.adjective(d, scale.points, lambda, coverage, densityf, cumulativef, TRUE))
expected.success.values <- sapply(scale.points, function(d) expected.success(d,  scale.points, densityf, cumulativef))
plotdata <- data.frame("Time" = scale.points, "P" = probability.of.thresholds, "sigma" = sigma.of.thresholds, "Success" = expected.success.values)
#plot probabilites
g1 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=P), fill="green", alpha=.4)
g2 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=sigma), fill="steelblue", alpha=.4)
g3 <- ggplot(plotdata) +
geom_area(aes(x=Time, y=Success), fill="steelblue", alpha=.4)
g1
sum(probability.of.thresholds)
g2
g3
