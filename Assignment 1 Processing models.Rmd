---
title: 'Lab assignment 1: Processing models'
author: "Luka van der Plas (4119142) & Rianne Lam (6888216)"
date: "15 november 2019"
output:
  html_document:
    df_print: paged
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Section I: Human data

### Question 1:

A.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
load("keyPressDataWithLaneDeviation.Rdata")
  
NoErr <- subset(keyPressDataWithLaneDeviation, typingErrorMadeOnTrial == 0)
totalDialingTime <- subset(NoErr, phoneNrLengthAfterKeyPress == 11)

summaryStatistics <- function(data) {
  meanCond <- mean(data)
  sdCond <- sd(data)
  seCond <- sdCond / sqrt(12)
  return(c(meanCond, sdCond, seCond))
}

summarizeData <- function(dataToSummarize) {

totalDialingTimePP <- aggregate(dataToSummarize[ , c("pp", "timeRelativeToTrialStart")], by = list(dataToSummarize$pp), FUN = mean)$timeRelativeToTrialStart

summary <- summaryStatistics(totalDialingTimePP)

return(summary)
} 
  
summaryDataCond1 <- summarizeData(subset(totalDialingTime, partOfExperiment == "dualSteerFocus"))
summaryDataCond2 <- summarizeData(subset(totalDialingTime, partOfExperiment == "dualDialFocus"))

dialingTime <- c(summaryDataCond1, summaryDataCond2)

results <- data.frame("M" = paste(round(c(summaryDataCond1[1], summaryDataCond2[1]), 3),  " ms"),
                   "SD" = paste(round(c(summaryDataCond1[2], summaryDataCond2[2]), 3),  " ms"),
                   "SE" = paste(round(c(summaryDataCond1[3], summaryDataCond2[3]), 3),  " ms"))
rownames(results) <- c("Steering focus", "Dialing focus")

results

```

B.

```{r, echo = FALSE, warning = FALSE, message = FALSE}

avg_dev_trial <- function(data, trialN) {
  dataTrial <- subset(data, data$trial == trialN)
  abs_lane_pos <- mean(abs(dataTrial$lanePosition), na.rm = TRUE)
  return(abs_lane_pos)
}

avg_dev_cond <- function(condition) {
  dataCond <- subset(NoErr, NoErr$partOfExperiment == condition) 
  ppCount <- max(dataCond$pp)
  abs_lane_pos <- vector()
  for (i in 1:ppCount) {
      dataCondpp <- subset(dataCond, dataCond$pp == i)
      trials <- unique(dataCondpp$trial)
    for (j in trials) {
      mean_abs_lane_pos <- avg_dev_trial(dataCondpp, j)
      abs_lane_pos <- append(abs_lane_pos, mean_abs_lane_pos)
    }
  }
  
  return(summaryStatistics(abs_lane_pos))
} 

steerFocus <- avg_dev_cond("dualSteerFocus")
dialFocus <- avg_dev_cond("dualDialFocus")

laneDev <- c(steerFocus, dialFocus)

results <- data.frame("M" = paste(round(c(steerFocus[1], dialFocus[1]), 3),  " m"),
                   "SD" = paste(round(c(steerFocus[2], dialFocus[2]), 3),  " m"),
                   "SE" = paste(round(c(steerFocus[3], dialFocus[3]), 3),  " m"))
rownames(results) <- c("Steering focus", "Dialing focus")

results

laneDev


```

C.

```{r, echo = FALSE, warning = FALSE, message = FALSE}

library(ggplot2)
library(dplyr)

mean_dev_pp_df <- NoErr %>%
  # Group by participant, keypress, condition
  group_by(pp, phoneNrLengthAfterKeyPress, partOfExperiment) %>%  
  # Take the mean of absolute lane position for these groups
  summarise(mean_dev_pp = mean(abs(lanePosition)))

mean_dev_all <- mean_dev_pp_df %>%
  # Group by keypress, condition
  group_by(phoneNrLengthAfterKeyPress, partOfExperiment) %>%
  # Take the mean of the mean for these groups per participant (mean across participants)
  summarise(mean_dev = mean(mean_dev_pp)) %>%
  # Only look at the two relevant conditions
  filter(partOfExperiment %in% c("dualDialFocus", "dualSteerFocus")) 

# Replace condition names for plot
mean_dev_all$partOfExperiment <- recode(mean_dev_all$partOfExperiment, "dualDialFocus" = "Dialing-focus", "dualSteerFocus" = "Steering-focus")

mean_dev_all

n <- max(unique(keyPressDataWithLaneDeviation$pp))

ggplot(mean_dev_all, aes(x = phoneNrLengthAfterKeyPress, y = mean_dev, group = partOfExperiment)) +
  geom_line(size = 1) +
  geom_point(aes(shape = factor(partOfExperiment)), size = 3.5) +
  theme_classic() +
  theme(legend.position = c(0.9, 0.1), legend.title = element_blank()) + 
  ylab("Lateral Deviation (m)") + 
  xlab("Number of key presses") + 
  geom_errorbar(aes(ymin = mean_dev - (sd(mean_dev) / sqrt(n)), ymax = mean_dev + (sd(mean_dev) / sqrt(n))), size = 1, width = 0.2, position = position_dodge(0.05)) +
  scale_x_continuous(breaks = seq(0, 12, 1)) 

```

D. For both conditions, it seems that participants did not interleave dialing for driving between the 5th and 6th key presses. At the 6th key press, the absolute lane deviation did not decrease compared to the 5th key press, while this would have been expected if participants were to focus on the road at this point.

However, in the dialing focus condition we can see that from the 6th key press onwards participants tend to focus less on the road and thus show greater absolute lane deviation. This gives a kind of breakpoint in the plot. But this result cannot be explained by the hypothesis that particpants would interleave dialing for driving at this point in time. 

### Question 2

A. 

```{r, echo = FALSE, warning = FALSE, message = FALSE}
load("tableOfDriftValuesCalibration.Rdata")

driftData <- subset(tableOfDriftValuesCalibration, trialTime >= 15000 & trialTime <= 18000)
driftData$trial <- as.factor(driftData$trial)

ggplot(driftData, aes(trialTime, posX)) +
  geom_line(aes(group = trial, color = trial)) +
  theme(legend.position = "none")


```

B.

```{r, echo = FALSE, warning = FALSE, message = FALSE}

#get trials and timesteps
trials <- unique(tableOfDriftValuesCalibration$trial)
timesteps <- 3000 / 50
timerange <- seq(0, 3000, 50)

#empty df
trial_data <- data.frame()

#add data for trials
for (t in trials) {
  deviations <- rnorm(timesteps, mean = 0, sd = 0.13)
  deviations <- cumsum(deviations)
  
  for (i in 1:length(deviations)) {
    trial_data <- rbind(trial_data, c(t, timerange[i], deviations[i]))
  }
}

#set column names
colnames(trial_data) <- c("trial", "time", "deviation")
trial_data$trial <- as.factor(trial_data$trial)

ggplot(trial_data, aes(time, deviation)) +
  geom_line(aes(group = trial, color = trial)) +
  theme(legend.position = "none")

```

C. 

```{r, echo = FALSE, warning = FALSE, message = FALSE}

min_pos <- min(min(driftData$posX), min(trial_data$deviation))
min_pos <- floor(min_pos * 10) / 10
max_pos <- max(max(driftData$posX), max(trial_data$deviation))
max_pos <- ceiling(max_pos * 10) / 10

ggplot(driftData, aes(posX)) +
  geom_histogram(binwidth = 0.2) +
  scale_x_continuous(breaks = seq(min_pos, max_pos, 0.2)) +
  coord_cartesian(xlim=  c(min_pos, max_pos), ylim=c(0, 350)) +
  xlab("lateral position") +
  ylab("frequency")

ggplot(trial_data, aes(deviation)) +
  geom_histogram(binwidth = 0.2) +
  scale_x_continuous(breaks = (breaks = seq(min_pos, max_pos, 0.2))) +
  coord_cartesian(xlim=  c(min_pos, max_pos), ylim=c(0, 350)) +
  xlab("lateral position") +
  ylab("frequency")

```

D.

```{r, echo = FALSE, warning = FALSE, message = FALSE}
sdDf <- data.frame("Data Type" = c("Human Data", "Simulated Data"), "Standard Deviation" = c(paste(0.359, "ms"), paste(0.710, "ms")))
                   
sdDf

```

E.

```{r, echo = FALSE, warning = FALSE, message = FALSE}

# Function

trySds <- function(sdToTry) {
  
  #get trials and timesteps
  trials <- 50
  timesteps <- 3000 / 50
  timerange <- seq(0, 3000, 50)
  
  #empty df
  trial_data <- data.frame()
  
  #add data for trials
  for (t in trials) {
    deviations <- rnorm(timesteps, mean = 0, sd = sdToTry)
    deviations <- cumsum(deviations)
    
    for (i in 1:length(deviations)) {
      trial_data <- rbind(trial_data, c(t, timerange[i], deviations[i]))
    }
  }
  
  #set column names
  colnames(trial_data) <- c("trial", "time", "deviation")
  trial_data$trial <- as.factor(trial_data$trial)
  
  plot1 <- ggplot(trial_data, aes(time, deviation)) +
    geom_line(aes(group = trial, color = trial)) +
    theme(legend.position = "none")
  
  plot2 <- ggplot(trial_data, aes(deviation)) +
    geom_histogram(binwidth = 0.2) +
    xlab("lateral position") +
    ylab("frequency")
  
  sdDiff <- abs(0.359 - sd(trial_data$deviation))
  
  return(sdDiff)
}

sdsToTry <- seq(0, 0.13, 0.001)
results <- vector()

for(i in sdsToTry) {
  results <- append(results, trySds(i))
}

# which(results == min(results))
# results[99]
# sdsToTry[99]

```

### Question 3

We changed the value of gaussDeviateSD to 0.07 and we changed the value of gaussDriveNoiseSD to 0.053 so that the difference would be the same ratio as of the previous standard deviations.

A. The average value of the interkeypress intervals is 273 (rounded towards the nearest integer).
B. We used 275 as the interkeypress interval for the model because we consider this amount of rounding to be appropriate. 

```{r, echo = FALSE, warning = FALSE, message = FALSE}

dataSingleDialing <- subset(NoErr, partOfExperiment == "singleDialing2")

totalTrialTime <- dataSingleDialing %>%
  select(-9) %>%
  group_by(pp, trial) %>%
  filter(phoneNrLengthAfterKeyPress == max(phoneNrLengthAfterKeyPress) & Event1 != "Start")

meanInterval <- totalTrialTime$timeRelativeToTrialStart / totalTrialTime$phoneNrLengthAfterKeyPress
  
meanIntervalAll <- round(sum(meanInterval) / length(meanInterval), 0)

```

### Question 4

A. 

1 simulation:

```{r, echo = FALSE, warning = FALSE, message = FALSE}

results1 <- runAllSimpleStrategies(nrSimulations = 1)

```

5 simulations:

```{r, echo = FALSE, warning = FALSE, message = FALSE}

results5 <- runAllSimpleStrategies(nrSimulations = 5)

```

10 simulations:

```{r, echo = FALSE, warning = FALSE, message = FALSE}

results10 <- runAllSimpleStrategies(nrSimulations = 10)

```

50 simulations:

```{r, echo = FALSE, warning = FALSE, message = FALSE}

results50 <- runAllSimpleStrategies(nrSimulations = 50)

```

100 simulations:

```{r, echo = FALSE, warning = FALSE, message = FALSE}

results100 <- runAllSimpleStrategies(nrSimulations = 100)

```

200 simulations:

```{r, echo = FALSE, warning = FALSE, message = FALSE}

results200 <- runAllSimpleStrategies(nrSimulations = 200)

```

```{r, echo = FALSE, warning = FALSE, message = FALSE}

data.frame("N of simulations"= c(1, 5, 10, 50, 100, 200), "Correlation trial time and lateral deviation"= c(results1, results5, results10, results50, results100, results200))

```

B. We can see that as the number of simulations increases, the data becomes less noisy and more stable. Additionally, as the number of simulations increases the range of the average lateral deviation decreases somewhat. Furthermore, we looked at the correlation between trial time and lateral deviation for all simulation lengths. The correlation becomes larger as the number of simulations increases, and clearly reaches a maximum at 100 simulations. This means that somewhere around 100 simulations is the optimal choice (data is stable an additional simulations provide no information gain anymore).
However, the computing time increases quite a bit as we reach 100-200 simulations. Therefore, we suggest that it would be best to use around 50 simulations when still working on the model, and then use around 100 simulations for the final model predictions. 

```{r, echo = FALSE, warning = FALSE, message = FALSE}

generate_strategies <- function(n) {
  #give all strategies of length n
  
  #base case
  if (n ==1) {
    return (matrix(c(FALSE, TRUE)))
  }
    
  #recursive definition
  tail <- generate_strategies(n - 1)
  count <- dim(tail)[1]
  
  start_0 <- cbind(matrix(rep(FALSE, count)), tail)
  start_1 <- cbind(matrix(rep(TRUE, count)), tail)
  
  return(rbind(start_0, start_1))
}

all_strategies <- generate_strategies(10)

give_breakpoints <- function(strat) {
  breakpoints <- c()
  
  for (i in 1:length(strat)) {
    if (strat[i]) {
      breakpoints <- c(breakpoints, c(i))
    }
  }
  breakpoints
}

steeringTimeOptions <- c(2,4,6,8,10,12)

```

```{r, echo = FALSE, message = FALSE, warning = FALSE}

runAllComplexStrategies <- function(nrSimulations,phoneNumber) {
	
	
	normalPhoneStructure <- c(1,6)  ### indicate at what digit positions a chunk needs to be retrieved (1st and 6th digit)
	phoneStringLength <- 11   ### how many digits does the number have?
	

	### vectors that will contain output of the simulation. These are later used to create 1 table with all values
	keypresses <- c()
	times <- c()
	deviations <- c()
	strats <- c()
	steers <- c()	

	### iterate through all strategies
	## in this simple model we assume that a participant uses a consistent strategy throughout the trial. That is, they only type each time 1 digit, or type 2 digits at a time, or type 3 digits at a time (i.e., all possible ways of 1:phoneStringLength: 1, 2,3,4, ...11)
	
	for (i in 1:nrow(all_strategies))
	{
		## quick way of calculating positions to interleave: repeat strategy & multiply with position in vector (e.g., 333*123 = 369 this means: you interleave BEFORE every 3rd digit (333), and there are 3 positions to interleave (1st, 2nd, 3rd, or 123). Therefore you interleave BEFORE digits 3 (3*1), 6 (3*2), and 9 (3*3))
	  
	  strategy <- give_breakpoints(all_strategies[i,])
		

		locSteerTimeOptions <- steeringTimeOptions
		if (length(strategy) == 0)
		{
			locSteerTimeOptions <- c(0)
		}



		### now run a trial (runOneTrial) for all combinations of how frequently you update the steering when you are steering (locSteerTimeOptions) and for the nuber of simulations that you want to run for each strategy (nrSimulations)
		for (steerTimes in locSteerTimeOptions)
		{
			for (j in 1:nrSimulations)
			{

				### run the simulation and store the output in a table
				locTab <- runOneTrial(strategy, steerTimes,normalPhoneStructure,phoneStringLength,phoneNumber)
	
				##only look at rows where there is a keypress
				locTab <- locTab[locTab$events == "keypress",]
		
				### add the relevant data points to variables that are stored in a final table
				keypresses <- c(keypresses,1:nrow(locTab))
				times <- c(times,locTab$times)
				deviations <- c(deviations,locTab$drifts)
				strats <- c(strats,rep(i,nrow(locTab)))
				steers <- c(steers,rep(steerTimes,nrow(locTab)))
		
			}
		}#end of for steerTimes	

	}##end of for nr strategies
	
	
	### now make a new table based on all the data that was collected
	tableAllSamples <- data.frame(keypresses,times,deviations,strats,steers)
	
	#### In the table we collected data for multiple simulations per strategy. Now we want to know the average performane of each strategy.
	#### These aspects are calculated using the "aggregate" function
	
	
	## calculate average deviation at each keypress (keypresses), for each unique strategy variation (strats and steers)
	agrResults <- with(tableAllSamples,aggregate(deviations,list(keypresses=keypresses, strats= strats, steers= steers),mean))
	agrResults$dev <- agrResults$x
	
	
	### also calculate the time interval
	agrResults$times <- with(tableAllSamples,aggregate(times,list(keypresses=keypresses, strats= strats, steers= steers),mean))$x
		
	
	###now calculate mean drift across the trial
	agrResultsMeanDrift <-  with(agrResults,aggregate(dev,list(strats= strats, steers= steers),mean))
	agrResultsMeanDrift$dev <- agrResultsMeanDrift$x
	
	### and mean trial time
	agrResultsMeanDrift$TrialTime <-  with(agrResults[agrResults$keypresses ==11,],aggregate(times,list( strats= strats, steers= steers),mean))$x	
	
	return(agrResultsMeanDrift)
}

```

```{r, echo = FALSE, warning = FALSE, message = FALSE}

results <- runAllComplexStrategies(nrSimulations = 50)

save(results, "ComplexStrategies50Sim.R")

results$TrialTime <- results$TrialTime / 1000

dialingTime <- dialingTime / 1000
dialTimeDialMean <- dialingTime[1]
dialTimeSteerMean <- dialingTime[4]
dialTimeDialSE <- dialingTime[3]
dialTimeSteerSE <- dialingTime[6]

laneDevDialMean <- laneDev[1]
laneDevSteerMean <- laneDev[4]
laneDevDialSE <- laneDev[3]
laneDevSteerSE <- laneDev[6]

#get trials that only interleave between 5 and 6

#find index of target strategy
target_strat <- c(FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)
target_strat_n <- 0
for(i in 1:nrow(all_strategies)) {
  if (identical(all_strategies[i,], target_strat)) {
    target_strat_n <- i
    break
  }
}

natural_breakpoint_sims <- subset(results, strats == target_strat_n)

library(ggplot2)

#plot all strategies
ggplot(data = results) +
  geom_point(aes(TrialTime, abs(dev), color="Simulations"), size = 0.2) +
  
  geom_point(aes(x = dialTimeSteerMean, y = laneDevSteerMean, color = "Steer focus trials")) +
  geom_errorbar(aes(x = dialTimeSteerMean, ymin = laneDevSteerMean - laneDevSteerSE, ymax = laneDevSteerMean + laneDevSteerSE, color = "Steer focus trials", width = 0.2)) +
  geom_errorbarh(aes(xmin = dialTimeSteerMean - dialTimeSteerSE, xmax = dialTimeSteerMean + dialTimeSteerSE, y = laneDevSteerMean, color = "Steer focus trials", height = 0.02)) +
  
  geom_point(aes(x = dialTimeDialMean , y = laneDevDialMean, color =  "Dial focus trials")) +
  geom_errorbar(aes(x = dialTimeDialMean , ymin = laneDevDialMean - laneDevDialSE, ymax = laneDevDialMean + laneDevDialSE, color =  "Dial focus trials", width = 0.2)) +
  geom_errorbarh(aes(xmin = dialTimeDialMean  - dialTimeDialSE, xmax = dialTimeDialMean  + dialTimeDialSE, y = laneDevDialMean, color =  "Dial focus trials", height = 0.02)) + 
  
  geom_point(data = natural_breakpoint_sims, aes(TrialTime, abs(dev), color="Natural breakpoint simulations")) +
  
  
  xlab("Dial time (s)") +
  ylab("Average Lateral Deviation (m)") +
  labs(color = "Data source")


```

C.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
library(dplyr)

stratsDial <- results %>%
  filter(TrialTime > (dialTimeDialMean - dialTimeDialSE) & TrialTime < (dialTimeDialMean + dialingTime[3])) %>%
           filter(abs(dev) > (laneDevDialMean - laneDevDialSE) & abs(dev) < (laneDevDialMean + laneDevDialSE))

stratsSteer <- results %>%
  filter(TrialTime > (dialTimeSteerMean - dialTimeSteerSE) & TrialTime < (dialTimeSteerMean + dialTimeSteerSE)) %>%
           filter(abs(dev) > (laneDevSteerMean - laneDevSteerSE) & abs(dev) < (laneDevSteerMean + laneDevSteerSE)) 

```




